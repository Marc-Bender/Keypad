
Keypad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000074  00800200  00000438  000004cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000438  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000024  00800274  00800274  00000540  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000540  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000570  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a0  00000000  00000000  000005b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000144d  00000000  00000000  00000650  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f10  00000000  00000000  00001a9d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000006db  00000000  00000000  000029ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000154  00000000  00000000  00003088  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000080d  00000000  00000000  000031dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000003dd  00000000  00000000  000039e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  00003dc6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	7b c0       	rjmp	.+246    	; 0xf8 <__ctors_end>
   2:	00 00       	nop
   4:	a7 c0       	rjmp	.+334    	; 0x154 <__bad_interrupt>
   6:	00 00       	nop
   8:	a5 c0       	rjmp	.+330    	; 0x154 <__bad_interrupt>
   a:	00 00       	nop
   c:	a3 c0       	rjmp	.+326    	; 0x154 <__bad_interrupt>
   e:	00 00       	nop
  10:	a1 c0       	rjmp	.+322    	; 0x154 <__bad_interrupt>
  12:	00 00       	nop
  14:	9f c0       	rjmp	.+318    	; 0x154 <__bad_interrupt>
  16:	00 00       	nop
  18:	9d c0       	rjmp	.+314    	; 0x154 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	9b c0       	rjmp	.+310    	; 0x154 <__bad_interrupt>
  1e:	00 00       	nop
  20:	99 c0       	rjmp	.+306    	; 0x154 <__bad_interrupt>
  22:	00 00       	nop
  24:	97 c0       	rjmp	.+302    	; 0x154 <__bad_interrupt>
  26:	00 00       	nop
  28:	95 c0       	rjmp	.+298    	; 0x154 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	93 c0       	rjmp	.+294    	; 0x154 <__bad_interrupt>
  2e:	00 00       	nop
  30:	91 c0       	rjmp	.+290    	; 0x154 <__bad_interrupt>
  32:	00 00       	nop
  34:	8f c0       	rjmp	.+286    	; 0x154 <__bad_interrupt>
  36:	00 00       	nop
  38:	8d c0       	rjmp	.+282    	; 0x154 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	8b c0       	rjmp	.+278    	; 0x154 <__bad_interrupt>
  3e:	00 00       	nop
  40:	89 c0       	rjmp	.+274    	; 0x154 <__bad_interrupt>
  42:	00 00       	nop
  44:	87 c0       	rjmp	.+270    	; 0x154 <__bad_interrupt>
  46:	00 00       	nop
  48:	85 c0       	rjmp	.+266    	; 0x154 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	83 c0       	rjmp	.+262    	; 0x154 <__bad_interrupt>
  4e:	00 00       	nop
  50:	81 c0       	rjmp	.+258    	; 0x154 <__bad_interrupt>
  52:	00 00       	nop
  54:	7f c0       	rjmp	.+254    	; 0x154 <__bad_interrupt>
  56:	00 00       	nop
  58:	7d c0       	rjmp	.+250    	; 0x154 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	7b c0       	rjmp	.+246    	; 0x154 <__bad_interrupt>
  5e:	00 00       	nop
  60:	79 c0       	rjmp	.+242    	; 0x154 <__bad_interrupt>
  62:	00 00       	nop
  64:	77 c0       	rjmp	.+238    	; 0x154 <__bad_interrupt>
  66:	00 00       	nop
  68:	a2 c1       	rjmp	.+836    	; 0x3ae <__vector_26>
  6a:	00 00       	nop
  6c:	73 c0       	rjmp	.+230    	; 0x154 <__bad_interrupt>
  6e:	00 00       	nop
  70:	71 c0       	rjmp	.+226    	; 0x154 <__bad_interrupt>
  72:	00 00       	nop
  74:	6f c0       	rjmp	.+222    	; 0x154 <__bad_interrupt>
  76:	00 00       	nop
  78:	6d c0       	rjmp	.+218    	; 0x154 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	6b c0       	rjmp	.+214    	; 0x154 <__bad_interrupt>
  7e:	00 00       	nop
  80:	69 c0       	rjmp	.+210    	; 0x154 <__bad_interrupt>
  82:	00 00       	nop
  84:	67 c0       	rjmp	.+206    	; 0x154 <__bad_interrupt>
  86:	00 00       	nop
  88:	65 c0       	rjmp	.+202    	; 0x154 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	63 c0       	rjmp	.+198    	; 0x154 <__bad_interrupt>
  8e:	00 00       	nop
  90:	61 c0       	rjmp	.+194    	; 0x154 <__bad_interrupt>
  92:	00 00       	nop
  94:	5f c0       	rjmp	.+190    	; 0x154 <__bad_interrupt>
  96:	00 00       	nop
  98:	5d c0       	rjmp	.+186    	; 0x154 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	5b c0       	rjmp	.+182    	; 0x154 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	59 c0       	rjmp	.+178    	; 0x154 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	57 c0       	rjmp	.+174    	; 0x154 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	55 c0       	rjmp	.+170    	; 0x154 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	53 c0       	rjmp	.+166    	; 0x154 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	51 c0       	rjmp	.+162    	; 0x154 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	4f c0       	rjmp	.+158    	; 0x154 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	4d c0       	rjmp	.+154    	; 0x154 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	4b c0       	rjmp	.+150    	; 0x154 <__bad_interrupt>
  be:	00 00       	nop
  c0:	49 c0       	rjmp	.+146    	; 0x154 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	47 c0       	rjmp	.+142    	; 0x154 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	45 c0       	rjmp	.+138    	; 0x154 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	43 c0       	rjmp	.+134    	; 0x154 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	41 c0       	rjmp	.+130    	; 0x154 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	3f c0       	rjmp	.+126    	; 0x154 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	3d c0       	rjmp	.+122    	; 0x154 <__bad_interrupt>
  da:	00 00       	nop
  dc:	3b c0       	rjmp	.+118    	; 0x154 <__bad_interrupt>
  de:	00 00       	nop
  e0:	39 c0       	rjmp	.+114    	; 0x154 <__bad_interrupt>
  e2:	00 00       	nop
  e4:	80 01       	movw	r16, r0
  e6:	86 01       	movw	r16, r12
  e8:	8c 01       	movw	r16, r24
  ea:	92 01       	movw	r18, r4
  ec:	98 01       	movw	r18, r16
  ee:	9e 01       	movw	r18, r28
  f0:	a4 01       	movw	r20, r8
  f2:	aa 01       	movw	r20, r20
  f4:	b0 01       	movw	r22, r0

000000f6 <__ctors_start>:
  f6:	cd 00       	.word	0x00cd	; ????

000000f8 <__ctors_end>:
  f8:	11 24       	eor	r1, r1
  fa:	1f be       	out	0x3f, r1	; 63
  fc:	cf ef       	ldi	r28, 0xFF	; 255
  fe:	d1 e2       	ldi	r29, 0x21	; 33
 100:	de bf       	out	0x3e, r29	; 62
 102:	cd bf       	out	0x3d, r28	; 61
 104:	00 e0       	ldi	r16, 0x00	; 0
 106:	0c bf       	out	0x3c, r16	; 60

00000108 <__do_copy_data>:
 108:	12 e0       	ldi	r17, 0x02	; 2
 10a:	a0 e0       	ldi	r26, 0x00	; 0
 10c:	b2 e0       	ldi	r27, 0x02	; 2
 10e:	e8 e3       	ldi	r30, 0x38	; 56
 110:	f4 e0       	ldi	r31, 0x04	; 4
 112:	00 e0       	ldi	r16, 0x00	; 0
 114:	0b bf       	out	0x3b, r16	; 59
 116:	02 c0       	rjmp	.+4      	; 0x11c <__do_copy_data+0x14>
 118:	07 90       	elpm	r0, Z+
 11a:	0d 92       	st	X+, r0
 11c:	a4 37       	cpi	r26, 0x74	; 116
 11e:	b1 07       	cpc	r27, r17
 120:	d9 f7       	brne	.-10     	; 0x118 <__do_copy_data+0x10>

00000122 <__do_clear_bss>:
 122:	22 e0       	ldi	r18, 0x02	; 2
 124:	a4 e7       	ldi	r26, 0x74	; 116
 126:	b2 e0       	ldi	r27, 0x02	; 2
 128:	01 c0       	rjmp	.+2      	; 0x12c <.do_clear_bss_start>

0000012a <.do_clear_bss_loop>:
 12a:	1d 92       	st	X+, r1

0000012c <.do_clear_bss_start>:
 12c:	a8 39       	cpi	r26, 0x98	; 152
 12e:	b2 07       	cpc	r27, r18
 130:	e1 f7       	brne	.-8      	; 0x12a <.do_clear_bss_loop>

00000132 <__do_global_ctors>:
 132:	10 e0       	ldi	r17, 0x00	; 0
 134:	cc e7       	ldi	r28, 0x7C	; 124
 136:	d0 e0       	ldi	r29, 0x00	; 0
 138:	00 e0       	ldi	r16, 0x00	; 0
 13a:	05 c0       	rjmp	.+10     	; 0x146 <__do_global_ctors+0x14>
 13c:	21 97       	sbiw	r28, 0x01	; 1
 13e:	01 09       	sbc	r16, r1
 140:	80 2f       	mov	r24, r16
 142:	fe 01       	movw	r30, r28
 144:	6f d1       	rcall	.+734    	; 0x424 <__tablejump2__>
 146:	cb 37       	cpi	r28, 0x7B	; 123
 148:	d1 07       	cpc	r29, r17
 14a:	80 e0       	ldi	r24, 0x00	; 0
 14c:	08 07       	cpc	r16, r24
 14e:	b1 f7       	brne	.-20     	; 0x13c <__do_global_ctors+0xa>
 150:	43 d0       	rcall	.+134    	; 0x1d8 <main>
 152:	70 c1       	rjmp	.+736    	; 0x434 <_exit>

00000154 <__bad_interrupt>:
 154:	55 cf       	rjmp	.-342    	; 0x0 <__vectors>

00000156 <writeToBuffer>:

/**
 * \brief Puts a byte into the buffer 
**/ 
void writeToBuffer(volatile GenericBuffers_t * const buf, const unsigned char chr)
{
 156:	fc 01       	movw	r30, r24
	buf->buffer[((buf->wrIndx)++)%MOD2BUFFER]=chr;
 158:	20 81       	ld	r18, Z
 15a:	31 81       	ldd	r19, Z+1	; 0x01
 15c:	c9 01       	movw	r24, r18
 15e:	01 96       	adiw	r24, 0x01	; 1
 160:	91 83       	std	Z+1, r25	; 0x01
 162:	80 83       	st	Z, r24
 164:	2f 71       	andi	r18, 0x1F	; 31
 166:	33 27       	eor	r19, r19
 168:	e2 0f       	add	r30, r18
 16a:	f3 1f       	adc	r31, r19
 16c:	64 83       	std	Z+4, r22	; 0x04
 16e:	08 95       	ret

00000170 <readFromBuffer>:

/**
 * \brief reads a byte from the buffer
**/ 
unsigned char readFromBuffer(volatile GenericBuffers_t * const buf)
{
 170:	fc 01       	movw	r30, r24
	return buf->buffer[((buf->rdIndx)++)%MOD2BUFFER];
 172:	22 81       	ldd	r18, Z+2	; 0x02
 174:	33 81       	ldd	r19, Z+3	; 0x03
 176:	c9 01       	movw	r24, r18
 178:	01 96       	adiw	r24, 0x01	; 1
 17a:	93 83       	std	Z+3, r25	; 0x03
 17c:	82 83       	std	Z+2, r24	; 0x02
 17e:	2f 71       	andi	r18, 0x1F	; 31
 180:	33 27       	eor	r19, r19
 182:	e2 0f       	add	r30, r18
 184:	f3 1f       	adc	r31, r19
 186:	84 81       	ldd	r24, Z+4	; 0x04
}
 188:	08 95       	ret

0000018a <bytesAvailableInBuffer>:

/**
 * \brief just returns the number of bytes available for reading without reading any values or changing any indices
**/ 
__attribute__((pure)) unsigned bytesAvailableInBuffer(volatile GenericBuffers_t const * const buf)  
{
 18a:	fc 01       	movw	r30, r24
  return buf->wrIndx - buf->rdIndx;
 18c:	80 81       	ld	r24, Z
 18e:	91 81       	ldd	r25, Z+1	; 0x01
 190:	22 81       	ldd	r18, Z+2	; 0x02
 192:	33 81       	ldd	r19, Z+3	; 0x03
}
 194:	82 1b       	sub	r24, r18
 196:	93 0b       	sbc	r25, r19
 198:	08 95       	ret

0000019a <mainInit>:
		{'\a','\a','\a','\a','\a'}, //R4
	};

	
__attribute__((constructor)) void mainInit(void)
{
 19a:	cf 93       	push	r28
 19c:	df 93       	push	r29
 19e:	e3 e2       	ldi	r30, 0x23	; 35
 1a0:	f2 e0       	ldi	r31, 0x02	; 2
 1a2:	6d e2       	ldi	r22, 0x2D	; 45
 1a4:	72 e0       	ldi	r23, 0x02	; 2
	for (uint8_t row=0;row<NUM_OF_ROWPINS;row++)
		*(rowpins[row]->DDRx) |= 1<<(rowpins[row]->pinnumber);
 1a6:	41 e0       	ldi	r20, 0x01	; 1
 1a8:	50 e0       	ldi	r21, 0x00	; 0
 1aa:	c1 91       	ld	r28, Z+
 1ac:	d1 91       	ld	r29, Z+
 1ae:	a8 81       	ld	r26, Y
 1b0:	b9 81       	ldd	r27, Y+1	; 0x01
 1b2:	2c 91       	ld	r18, X
 1b4:	ca 01       	movw	r24, r20
 1b6:	0e 80       	ldd	r0, Y+6	; 0x06
 1b8:	02 c0       	rjmp	.+4      	; 0x1be <mainInit+0x24>
 1ba:	88 0f       	add	r24, r24
 1bc:	99 1f       	adc	r25, r25
 1be:	0a 94       	dec	r0
 1c0:	e2 f7       	brpl	.-8      	; 0x1ba <mainInit+0x20>
 1c2:	82 2b       	or	r24, r18
 1c4:	8c 93       	st	X, r24
	};

	
__attribute__((constructor)) void mainInit(void)
{
	for (uint8_t row=0;row<NUM_OF_ROWPINS;row++)
 1c6:	e6 17       	cp	r30, r22
 1c8:	f7 07       	cpc	r31, r23
 1ca:	79 f7       	brne	.-34     	; 0x1aa <mainInit+0x10>
		*(rowpins[row]->DDRx) |= 1<<(rowpins[row]->pinnumber);
	USART0_init(USARTBaudRate_9600);
 1cc:	81 e0       	ldi	r24, 0x01	; 1
 1ce:	d4 d0       	rcall	.+424    	; 0x378 <USART0_init>
	sei();
 1d0:	78 94       	sei
}
 1d2:	df 91       	pop	r29
 1d4:	cf 91       	pop	r28
 1d6:	08 95       	ret

000001d8 <main>:

#pragma GCC diagnostic ignored "-Wmain"
__attribute__((noreturn)) void main(void)
{
 1d8:	0f 2e       	mov	r0, r31
 1da:	f3 e2       	ldi	r31, 0x23	; 35
 1dc:	2f 2e       	mov	r2, r31
 1de:	f2 e0       	ldi	r31, 0x02	; 2
 1e0:	3f 2e       	mov	r3, r31
 1e2:	f0 2d       	mov	r31, r0
    /* Replace with your application code */
    while (1) 
    {	
		for(uint8_t col=0;col<NUM_OF_COLPINS;col++) 
		{
			*(colpins[col]->PORTx) |= 1<<colpins[col]->pinnumber; // one colpin as input w/ pullups 
 1e4:	aa 24       	eor	r10, r10
 1e6:	a3 94       	inc	r10
 1e8:	b1 2c       	mov	r11, r1
 1ea:	0f 2e       	mov	r0, r31
 1ec:	fd e2       	ldi	r31, 0x2D	; 45
 1ee:	8f 2e       	mov	r8, r31
 1f0:	f2 e0       	ldi	r31, 0x02	; 2
 1f2:	9f 2e       	mov	r9, r31
 1f4:	f0 2d       	mov	r31, r0
 1f6:	0f 2e       	mov	r0, r31
 1f8:	f9 e1       	ldi	r31, 0x19	; 25
 1fa:	6f 2e       	mov	r6, r31
 1fc:	f2 e0       	ldi	r31, 0x02	; 2
 1fe:	7f 2e       	mov	r7, r31
 200:	f0 2d       	mov	r31, r0
 202:	0f 2e       	mov	r0, r31
 204:	f0 e0       	ldi	r31, 0x00	; 0
 206:	4f 2e       	mov	r4, r31
 208:	f2 e0       	ldi	r31, 0x02	; 2
 20a:	5f 2e       	mov	r5, r31
 20c:	f0 2d       	mov	r31, r0
 20e:	d3 01       	movw	r26, r6
 210:	ed 90       	ld	r14, X+
 212:	fd 90       	ld	r15, X+
 214:	3d 01       	movw	r6, r26
 216:	d7 01       	movw	r26, r14
 218:	12 96       	adiw	r26, 0x02	; 2
 21a:	ed 91       	ld	r30, X+
 21c:	fc 91       	ld	r31, X
 21e:	13 97       	sbiw	r26, 0x03	; 3
 220:	20 81       	ld	r18, Z
 222:	c5 01       	movw	r24, r10
 224:	16 96       	adiw	r26, 0x06	; 6
 226:	0c 90       	ld	r0, X
 228:	02 c0       	rjmp	.+4      	; 0x22e <main+0x56>
 22a:	88 0f       	add	r24, r24
 22c:	99 1f       	adc	r25, r25
 22e:	0a 94       	dec	r0
 230:	e2 f7       	brpl	.-8      	; 0x22a <main+0x52>
 232:	82 2b       	or	r24, r18
 234:	80 83       	st	Z, r24
 236:	03 e2       	ldi	r16, 0x23	; 35
 238:	12 e0       	ldi	r17, 0x02	; 2
 23a:	62 01       	movw	r12, r4
			for (uint8_t row=0;row<NUM_OF_ROWPINS;row++)
			{
				*(rowpins[row]->PORTx) &= ~(1<<(rowpins[row]->pinnumber));
 23c:	f8 01       	movw	r30, r16
 23e:	c1 91       	ld	r28, Z+
 240:	d1 91       	ld	r29, Z+
 242:	8f 01       	movw	r16, r30
 244:	ea 81       	ldd	r30, Y+2	; 0x02
 246:	fb 81       	ldd	r31, Y+3	; 0x03
 248:	90 81       	ld	r25, Z
 24a:	95 01       	movw	r18, r10
 24c:	0e 80       	ldd	r0, Y+6	; 0x06
 24e:	02 c0       	rjmp	.+4      	; 0x254 <main+0x7c>
 250:	22 0f       	add	r18, r18
 252:	33 1f       	adc	r19, r19
 254:	0a 94       	dec	r0
 256:	e2 f7       	brpl	.-8      	; 0x250 <main+0x78>
 258:	82 2f       	mov	r24, r18
 25a:	80 95       	com	r24
 25c:	89 23       	and	r24, r25
 25e:	80 83       	st	Z, r24
				if(!(*(colpins[col]->PINx) & (1<<colpins[col]->pinnumber))) // if that pin is low there it is connected to some row pin that drives it low
 260:	d7 01       	movw	r26, r14
 262:	14 96       	adiw	r26, 0x04	; 4
 264:	ed 91       	ld	r30, X+
 266:	fc 91       	ld	r31, X
 268:	15 97       	sbiw	r26, 0x05	; 5
 26a:	80 81       	ld	r24, Z
 26c:	90 e0       	ldi	r25, 0x00	; 0
 26e:	16 96       	adiw	r26, 0x06	; 6
 270:	0c 90       	ld	r0, X
 272:	02 c0       	rjmp	.+4      	; 0x278 <main+0xa0>
 274:	95 95       	asr	r25
 276:	87 95       	ror	r24
 278:	0a 94       	dec	r0
 27a:	e2 f7       	brpl	.-8      	; 0x274 <main+0x9c>
 27c:	80 fd       	sbrc	r24, 0
 27e:	03 c0       	rjmp	.+6      	; 0x286 <main+0xae>
				{
					USART0_SendChar(keyMatrixIndicesToCharLUT[row][col]);
 280:	f6 01       	movw	r30, r12
 282:	80 81       	ld	r24, Z
 284:	8a d0       	rcall	.+276    	; 0x39a <USART0_SendChar>
				}
				*(rowpins[row]->PORTx) |= (1<<rowpins[row]->pinnumber);
 286:	ea 81       	ldd	r30, Y+2	; 0x02
 288:	fb 81       	ldd	r31, Y+3	; 0x03
 28a:	20 81       	ld	r18, Z
 28c:	c5 01       	movw	r24, r10
 28e:	0e 80       	ldd	r0, Y+6	; 0x06
 290:	02 c0       	rjmp	.+4      	; 0x296 <main+0xbe>
 292:	88 0f       	add	r24, r24
 294:	99 1f       	adc	r25, r25
 296:	0a 94       	dec	r0
 298:	e2 f7       	brpl	.-8      	; 0x292 <main+0xba>
 29a:	82 2b       	or	r24, r18
 29c:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 29e:	8f e5       	ldi	r24, 0x5F	; 95
 2a0:	9d e6       	ldi	r25, 0x6D	; 109
 2a2:	01 97       	sbiw	r24, 0x01	; 1
 2a4:	f1 f7       	brne	.-4      	; 0x2a2 <main+0xca>
 2a6:	00 c0       	rjmp	.+0      	; 0x2a8 <main+0xd0>
 2a8:	00 00       	nop
 2aa:	95 e0       	ldi	r25, 0x05	; 5
 2ac:	c9 0e       	add	r12, r25
 2ae:	d1 1c       	adc	r13, r1
    while (1) 
    {	
		for(uint8_t col=0;col<NUM_OF_COLPINS;col++) 
		{
			*(colpins[col]->PORTx) |= 1<<colpins[col]->pinnumber; // one colpin as input w/ pullups 
			for (uint8_t row=0;row<NUM_OF_ROWPINS;row++)
 2b0:	08 15       	cp	r16, r8
 2b2:	19 05       	cpc	r17, r9
 2b4:	19 f6       	brne	.-122    	; 0x23c <main+0x64>
					USART0_SendChar(keyMatrixIndicesToCharLUT[row][col]);
				}
				*(rowpins[row]->PORTx) |= (1<<rowpins[row]->pinnumber);
				_delay_ms(7);
			}
			*(colpins[col]->PORTx) &= ~(1<<colpins[col]->pinnumber); // tristate the pin
 2b6:	d7 01       	movw	r26, r14
 2b8:	12 96       	adiw	r26, 0x02	; 2
 2ba:	ed 91       	ld	r30, X+
 2bc:	fc 91       	ld	r31, X
 2be:	13 97       	sbiw	r26, 0x03	; 3
 2c0:	90 81       	ld	r25, Z
 2c2:	95 01       	movw	r18, r10
 2c4:	16 96       	adiw	r26, 0x06	; 6
 2c6:	0c 90       	ld	r0, X
 2c8:	02 c0       	rjmp	.+4      	; 0x2ce <main+0xf6>
 2ca:	22 0f       	add	r18, r18
 2cc:	33 1f       	adc	r19, r19
 2ce:	0a 94       	dec	r0
 2d0:	e2 f7       	brpl	.-8      	; 0x2ca <main+0xf2>
 2d2:	82 2f       	mov	r24, r18
 2d4:	80 95       	com	r24
 2d6:	89 23       	and	r24, r25
 2d8:	80 83       	st	Z, r24
 2da:	bf ef       	ldi	r27, 0xFF	; 255
 2dc:	4b 1a       	sub	r4, r27
 2de:	5b 0a       	sbc	r5, r27
__attribute__((noreturn)) void main(void)
{
    /* Replace with your application code */
    while (1) 
    {	
		for(uint8_t col=0;col<NUM_OF_COLPINS;col++) 
 2e0:	62 14       	cp	r6, r2
 2e2:	73 04       	cpc	r7, r3
 2e4:	09 f0       	breq	.+2      	; 0x2e8 <main+0x110>
 2e6:	93 cf       	rjmp	.-218    	; 0x20e <main+0x36>
 2e8:	86 cf       	rjmp	.-244    	; 0x1f6 <main+0x1e>

000002ea <setBaudrate>:
	for(uint8_t i=0;i<length;i++)
	{
		writeToBuffer(&txBuffer, string[i]);
	}
	USART0_enableDataRegisterEmptyInterrupt();
}
 2ea:	90 e0       	ldi	r25, 0x00	; 0
 2ec:	fc 01       	movw	r30, r24
 2ee:	32 97       	sbiw	r30, 0x02	; 2
 2f0:	e9 30       	cpi	r30, 0x09	; 9
 2f2:	f1 05       	cpc	r31, r1
 2f4:	d8 f5       	brcc	.+118    	; 0x36c <setBaudrate+0x82>
 2f6:	88 27       	eor	r24, r24
 2f8:	ee 58       	subi	r30, 0x8E	; 142
 2fa:	ff 4f       	sbci	r31, 0xFF	; 255
 2fc:	8f 4f       	sbci	r24, 0xFF	; 255
 2fe:	92 c0       	rjmp	.+292    	; 0x424 <__tablejump2__>
 300:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 304:	8a e8       	ldi	r24, 0x8A	; 138
 306:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 30a:	08 95       	ret
 30c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 310:	88 e6       	ldi	r24, 0x68	; 104
 312:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 316:	08 95       	ret
 318:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 31c:	85 e4       	ldi	r24, 0x45	; 69
 31e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 322:	08 95       	ret
 324:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 328:	84 e3       	ldi	r24, 0x34	; 52
 32a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 32e:	08 95       	ret
 330:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 334:	83 e2       	ldi	r24, 0x23	; 35
 336:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 33a:	08 95       	ret
 33c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 340:	82 e2       	ldi	r24, 0x22	; 34
 342:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 346:	08 95       	ret
 348:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 34c:	81 e1       	ldi	r24, 0x11	; 17
 34e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 352:	08 95       	ret
 354:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 358:	8f e0       	ldi	r24, 0x0F	; 15
 35a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 35e:	08 95       	ret
 360:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 364:	87 e0       	ldi	r24, 0x07	; 7
 366:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 36a:	08 95       	ret
 36c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
 370:	80 ed       	ldi	r24, 0xD0	; 208
 372:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
 376:	08 95       	ret

00000378 <USART0_init>:
 378:	b8 df       	rcall	.-144    	; 0x2ea <setBaudrate>
 37a:	e0 ec       	ldi	r30, 0xC0	; 192
 37c:	f0 e0       	ldi	r31, 0x00	; 0
 37e:	80 81       	ld	r24, Z
 380:	82 60       	ori	r24, 0x02	; 2
 382:	80 83       	st	Z, r24
 384:	e1 ec       	ldi	r30, 0xC1	; 193
 386:	f0 e0       	ldi	r31, 0x00	; 0
 388:	80 81       	ld	r24, Z
 38a:	88 60       	ori	r24, 0x08	; 8
 38c:	80 83       	st	Z, r24
 38e:	e2 ec       	ldi	r30, 0xC2	; 194
 390:	f0 e0       	ldi	r31, 0x00	; 0
 392:	80 81       	ld	r24, Z
 394:	86 60       	ori	r24, 0x06	; 6
 396:	80 83       	st	Z, r24
 398:	08 95       	ret

0000039a <USART0_SendChar>:
/**
 * \brief likewise this function is there to add a single character to the tx buffer so you do not have to call the send string function with an argument of size one and then even tell it that the size is one. 
**/
void USART0_SendChar(IN_PAR const char chr)
{
	writeToBuffer(&txBuffer, chr);
 39a:	68 2f       	mov	r22, r24
 39c:	84 e7       	ldi	r24, 0x74	; 116
 39e:	92 e0       	ldi	r25, 0x02	; 2
 3a0:	da de       	rcall	.-588    	; 0x156 <writeToBuffer>
 * \brief sets the bit that enables interrupt-generation when the data register is empty and thus it is possible to write a new / next value in there to have it transferred over the serial interface.
 * This makes polling of the interrupt-generating bit superfluous.
**/
inline void USART0_enableDataRegisterEmptyInterrupt(void)
{
	UCSR0B |= (1<<UDRIE0);
 3a2:	e1 ec       	ldi	r30, 0xC1	; 193
 3a4:	f0 e0       	ldi	r31, 0x00	; 0
 3a6:	80 81       	ld	r24, Z
 3a8:	80 62       	ori	r24, 0x20	; 32
 3aa:	80 83       	st	Z, r24
 3ac:	08 95       	ret

000003ae <__vector_26>:

/**
 * \brief This function initializes a USART interface just enough so you can send some stuff with it. This essentially is just a code example from Microchip / Atmel that has been lightly modified.
**/ 
void USART0_init(IN_PAR const USARTBaudRate_t baudrate)
{
 3ae:	1f 92       	push	r1
 3b0:	0f 92       	push	r0
 3b2:	0f b6       	in	r0, 0x3f	; 63
 3b4:	0f 92       	push	r0
 3b6:	11 24       	eor	r1, r1
 3b8:	0b b6       	in	r0, 0x3b	; 59
 3ba:	0f 92       	push	r0
 3bc:	2f 93       	push	r18
 3be:	3f 93       	push	r19
 3c0:	4f 93       	push	r20
 3c2:	5f 93       	push	r21
 3c4:	6f 93       	push	r22
 3c6:	7f 93       	push	r23
 3c8:	8f 93       	push	r24
 3ca:	9f 93       	push	r25
 3cc:	af 93       	push	r26
 3ce:	bf 93       	push	r27
 3d0:	ef 93       	push	r30
 3d2:	ff 93       	push	r31
 3d4:	e0 ec       	ldi	r30, 0xC0	; 192
 3d6:	f0 e0       	ldi	r31, 0x00	; 0
 3d8:	80 81       	ld	r24, Z
 3da:	80 62       	ori	r24, 0x20	; 32
 3dc:	80 83       	st	Z, r24
 3de:	84 e7       	ldi	r24, 0x74	; 116
 3e0:	92 e0       	ldi	r25, 0x02	; 2
 3e2:	d3 de       	rcall	.-602    	; 0x18a <bytesAvailableInBuffer>
 3e4:	89 2b       	or	r24, r25
 3e6:	31 f0       	breq	.+12     	; 0x3f4 <__vector_26+0x46>
 3e8:	84 e7       	ldi	r24, 0x74	; 116
 3ea:	92 e0       	ldi	r25, 0x02	; 2
 3ec:	c1 de       	rcall	.-638    	; 0x170 <readFromBuffer>
 3ee:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
 3f2:	05 c0       	rjmp	.+10     	; 0x3fe <__vector_26+0x50>
 3f4:	e1 ec       	ldi	r30, 0xC1	; 193
 3f6:	f0 e0       	ldi	r31, 0x00	; 0
 3f8:	80 81       	ld	r24, Z
 3fa:	8f 7d       	andi	r24, 0xDF	; 223
 3fc:	80 83       	st	Z, r24
 3fe:	ff 91       	pop	r31
 400:	ef 91       	pop	r30
 402:	bf 91       	pop	r27
 404:	af 91       	pop	r26
 406:	9f 91       	pop	r25
 408:	8f 91       	pop	r24
 40a:	7f 91       	pop	r23
 40c:	6f 91       	pop	r22
 40e:	5f 91       	pop	r21
 410:	4f 91       	pop	r20
 412:	3f 91       	pop	r19
 414:	2f 91       	pop	r18
 416:	0f 90       	pop	r0
 418:	0b be       	out	0x3b, r0	; 59
 41a:	0f 90       	pop	r0
 41c:	0f be       	out	0x3f, r0	; 63
 41e:	0f 90       	pop	r0
 420:	1f 90       	pop	r1
 422:	18 95       	reti

00000424 <__tablejump2__>:
 424:	ee 0f       	add	r30, r30
 426:	ff 1f       	adc	r31, r31
 428:	88 1f       	adc	r24, r24
 42a:	8b bf       	out	0x3b, r24	; 59
 42c:	07 90       	elpm	r0, Z+
 42e:	f6 91       	elpm	r31, Z
 430:	e0 2d       	mov	r30, r0
 432:	19 94       	eijmp

00000434 <_exit>:
 434:	f8 94       	cli

00000436 <__stop_program>:
 436:	ff cf       	rjmp	.-2      	; 0x436 <__stop_program>
